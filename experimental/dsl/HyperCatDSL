"""
HyperCat Functional DSL
Clean, composable API for category construction and manipulation
"""

from typing import List, Dict, Set, Tuple, Any, Optional, Callable, Union
from dataclasses import dataclass
from functools import reduce
import operator
from hypercat.core.core import Category, Object, Morphism, Functor, NaturalTransformation

# ============================================================================
# CORE DSL TYPES
# ============================================================================

@dataclass(frozen=True)
class Cat:
    """Immutable category representation for functional manipulation"""
    name: str
    objects: frozenset
    morphisms: frozenset
    composition: frozendict  # (Morphism, Morphism) -> Morphism
    identities: frozendict   # Object -> Morphism
    
    def to_hypercat(self) -> Category:
        """Convert to mutable HyperCat Category"""
        cat = Category(self.name)
        
        # Add objects
        for obj in self.objects:
            cat.add_object(obj)
        
        # Add morphisms  
        for morph in self.morphisms:
            cat.add_morphism(morph)
        
        # Set compositions
        for (f, g), h in self.composition.items():
            cat.set_composition(f, g, h)
        
        return cat

@dataclass(frozen=True) 
class Obj:
    """Immutable object with data"""
    name: str
    data: Any = None
    
    def __str__(self):
        return self.name

@dataclass(frozen=True)
class Mor:
    """Immutable morphism with data"""  
    name: str
    source: Obj
    target: Obj
    data: Any = None
    
    def __str__(self):
        return f"{self.name}: {self.source} → {self.target}"

# ============================================================================
# FUNCTIONAL BUILDERS
# ============================================================================

class CategoryBuilder:
    """Fluent functional API for building categories"""
    
    def __init__(self, name: str):
        self.name = name
        self._objects = set()
        self._morphisms = set()
        self._composition = {}
        self._identities = {}
    
    # OBJECT OPERATIONS
    def with_objects(self, *obj_specs) -> 'CategoryBuilder':
        """Add objects functionally"""
        for spec in obj_specs:
            if isinstance(spec, str):
                self._objects.add(Obj(spec))
            elif isinstance(spec, Obj):
                self._objects.add(spec)
            elif isinstance(spec, (list, tuple)) and len(spec) == 2:
                name, data = spec
                self._objects.add(Obj(name, data))
            else:
                raise ValueError(f"Invalid object spec: {spec}")
        return self
    
    def with_finite_sets(self, max_size: int) -> 'CategoryBuilder':
        """Add finite sets as objects"""
        for size in range(max_size + 1):
            if size == 0:
                data = set()
                name = "∅"
            else:
                data = set(range(1, size + 1))
                name = f"{{{','.join(map(str, data))}}}"
            self._objects.add(Obj(name, data))
        return self
    
    def with_poset(self, elements: List, order: List[Tuple]) -> 'CategoryBuilder':
        """Add poset elements as objects"""
        for elem in elements:
            self._objects.add(Obj(str(elem), elem))
        
        # Add order morphisms
        for (a, b) in order:
            a_obj = next(obj for obj in self._objects if obj.data == a)
            b_obj = next(obj for obj in self._objects if obj.data == b)
            
            morph_name = f"{a}≤{b}" if a != b else f"id_{a}"
            self._morphisms.add(Mor(morph_name, a_obj, b_obj, {'type': 'order'}))
        
        return self
    
    # MORPHISM OPERATIONS
    def with_morphisms(self, *morph_specs) -> 'CategoryBuilder':
        """Add morphisms functionally"""
        for spec in morph_specs:
            if isinstance(spec, Mor):
                self._morphisms.add(spec)
            elif isinstance(spec, (list, tuple)) and len(spec) >= 3:
                name, source_name, target_name = spec[:3]
                data = spec[3] if len(spec) > 3 else None
                
                source = self._find_object(source_name)
                target = self._find_object(target_name)
                
                if source and target:
                    self._morphisms.add(Mor(name, source, target, data))
            else:
                raise ValueError(f"Invalid morphism spec: {spec}")
        return self
    
    def with_functions(self, func_dict: Dict[str, Callable]) -> 'CategoryBuilder':
        """Add functions between finite set objects"""
        for name, func in func_dict.items():
            # Try to infer source/target from function name or use heuristics
            # This is simplified - could be made more sophisticated
            for source_obj in self._objects:
                for target_obj in self._objects:
                    if (hasattr(source_obj.data, '__iter__') and 
                        hasattr(target_obj.data, '__iter__')):
                        try:
                            # Test if function works on source data
                            test_elem = next(iter(source_obj.data)) if source_obj.data else None
                            if test_elem is not None:
                                func(test_elem)
                                self._morphisms.add(Mor(name, source_obj, target_obj, {
                                    'type': 'function',
                                    'function': func
                                }))
                                break
                        except:
                            continue
        return self
    
    def with_all_morphisms_between(self, source_names: List[str], 
                                   target_names: List[str]) -> 'CategoryBuilder':
        """Add all possible morphisms between specified objects"""
        for src_name in source_names:
            for tgt_name in target_names:
                source = self._find_object(src_name)
                target = self._find_object(tgt_name)
                if source and target:
                    morph_name = f"{src_name}→{tgt_name}"
                    self._morphisms.add(Mor(morph_name, source, target))
        return self
    
    # COMPOSITION OPERATIONS
    def with_compositions(self, *comp_specs) -> 'CategoryBuilder':
        """Add composition rules"""
        for spec in comp_specs:
            if len(spec) == 3:
                f_name, g_name, h_name = spec
                f = self._find_morphism(f_name)
                g = self._find_morphism(g_name)
                h = self._find_morphism(h_name)
                
                if f and g and h:
                    self._composition[(f, g)] = h
        return self
    
    def with_free_composition(self) -> 'CategoryBuilder':
        """Add all possible compositions automatically"""
        # This would implement free category construction
        # Simplified version here
        for f in self._morphisms:
            for g in self._morphisms:
                if f.target == g.source and (f, g) not in self._composition:
                    comp_name = f"{g.name}∘{f.name}"
                    comp_morph = Mor(comp_name, f.source, g.target, {
                        'type': 'composition',
                        'factors': [f, g]
                    })
                    self._morphisms.add(comp_morph)
                    self._composition[(f, g)] = comp_morph
        return self
    
    # UTILITIES
    def _find_object(self, name: str) -> Optional[Obj]:
        """Find object by name"""
        for obj in self._objects:
            if obj.name == name:
                return obj
        return None
    
    def _find_morphism(self, name: str) -> Optional[Mor]:
        """Find morphism by name"""
        for morph in self._morphisms:
            if morph.name == name:
                return morph
        return None
    
    # BUILD
    def build(self) -> Cat:
        """Build immutable category"""
        # Add identity morphisms
        for obj in self._objects:
            id_morph = Mor(f"id_{obj.name}", obj, obj, {'type': 'identity'})
            self._morphisms.add(id_morph)
            self._identities[obj] = id_morph
        
        return Cat(
            name=self.name,
            objects=frozenset(self._objects),
            morphisms=frozenset(self._morphisms),
            composition=frozendict(self._composition),
            identities=frozendict(self._identities)
        )

# ============================================================================
# FUNCTIONAL COMBINATORS
# ============================================================================

def cat(name: str) -> CategoryBuilder:
    """Start building a category"""
    return CategoryBuilder(name)

def objects(*specs) -> Callable[[CategoryBuilder], CategoryBuilder]:
    """Combinator for adding objects"""
    return lambda builder: builder.with_objects(*specs)

def morphisms(*specs) -> Callable[[CategoryBuilder], CategoryBuilder]:
    """Combinator for adding morphisms"""
    return lambda builder: builder.with_morphisms(*specs)

def finite_sets(max_size: int) -> Callable[[CategoryBuilder], CategoryBuilder]:
    """Combinator for finite sets"""
    return lambda builder: builder.with_finite_sets(max_size)

def poset(elements: List, order: List[Tuple]) -> Callable[[CategoryBuilder], CategoryBuilder]:
    """Combinator for posets"""
    return lambda builder: builder.with_poset(elements, order)

def free_composition() -> Callable[[CategoryBuilder], CategoryBuilder]:
    """Combinator for free composition"""
    return lambda builder: builder.with_free_composition()

# Pipe operator for functional composition
def pipe(initial_value, *functions):
    """Functional pipe operator"""
    return reduce(lambda acc, func: func(acc), functions, initial_value)

# ============================================================================
# CATEGORY OPERATIONS
# ============================================================================

def product_category(cat1: Cat, cat2: Cat) -> Cat:
    """Functional product of categories"""
    name = f"{cat1.name} × {cat2.name}"
    
    # Product objects
    prod_objects = {
        Obj(f"({obj1.name},{obj2.name})", (obj1.data, obj2.data))
        for obj1 in cat1.objects
        for obj2 in cat2.objects
    }
    
    # Product morphisms
    prod_morphisms = {
        Mor(f"({f.name},{g.name})", 
            Obj(f"({f.source.name},{g.source.name})", (f.source.data, g.source.data)),
            Obj(f"({f.target.name},{g.target.name})", (f.target.data, g.target.data)),
            {'type': 'product_morphism', 'factors': (f, g)})
        for f in cat1.morphisms
        for g in cat2.morphisms
    }
    
    return Cat(
        name=name,
        objects=frozenset(prod_objects),
        morphisms=frozenset(prod_morphisms),
        composition=frozendict(),  # Would need to implement composition
        identities=frozendict()
    )

def opposite_category(cat: Cat) -> Cat:
    """Functional opposite category"""
    name = f"{cat.name}^op"
    
    # Same objects
    op_objects = cat.objects
    
    # Reverse morphisms
    op_morphisms = {
        Mor(f"{morph.name}^op", morph.target, morph.source, morph.data)
        for morph in cat.morphisms
    }
    
    return Cat(
        name=name,
        objects=op_objects,
        morphisms=frozenset(op_morphisms),
        composition=frozendict(),  # Would reverse composition
        identities=cat.identities
    )

def slice_category(cat: Cat, base_obj: Obj) -> Cat:
    """Functional slice category cat/base_obj"""
    name = f"{cat.name}/{base_obj.name}"
    
    # Objects are morphisms to base_obj
    slice_objects = {
        Obj(f"{morph.source.name}→{base_obj.name}", morph)
        for morph in cat.morphisms
        if morph.target == base_obj
    }
    
    return Cat(
        name=name,
        objects=frozenset(slice_objects),
        morphisms=frozenset(),  # Would need to implement slice morphisms
        composition=frozendict(),
        identities=frozendict()
    )

# ============================================================================
# FUNCTOR DSL
# ============================================================================

@dataclass(frozen=True)
class Fun:
    """Immutable functor representation"""
    name: str
    source: Cat
    target: Cat
    object_map: frozendict
    morphism_map: frozendict

def functor(name: str, source: Cat, target: Cat) -> 'FunctorBuilder':
    """Start building a functor"""
    return FunctorBuilder(name, source, target)

class FunctorBuilder:
    """Functional functor builder"""
    
    def __init__(self, name: str, source: Cat, target: Cat):
        self.name = name
        self.source = source
        self.target = target
        self._object_map = {}
        self._morphism_map = {}
    
    def on_objects(self, mapping: Dict[str, str]) -> 'FunctorBuilder':
        """Map objects by name"""
        for src_name, tgt_name in mapping.items():
            src_obj = next(obj for obj in self.source.objects if obj.name == src_name)
            tgt_obj = next(obj for obj in self.target.objects if obj.name == tgt_name)
            self._object_map[src_obj] = tgt_obj
        return self
    
    def on_morphisms(self, mapping: Dict[str, str]) -> 'FunctorBuilder':
        """Map morphisms by name"""
        for src_name, tgt_name in mapping.items():
            src_morph = next(m for m in self.source.morphisms if m.name == src_name)
            tgt_morph = next(m for m in self.target.morphisms if m.name == tgt_name)
            self._morphism_map[src_morph] = tgt_morph
        return self
    
    def build(self) -> Fun:
        """Build immutable functor"""
        return Fun(
            name=self.name,
            source=self.source,
            target=self.target,
            object_map=frozendict(self._object_map),
            morphism_map=frozendict(self._morphism_map)
        )

# ============================================================================
# EXAMPLES AND DEMONSTRATIONS
# ============================================================================

def demonstrate_dsl():
    """Demonstrate the functional DSL"""
    
    print("🎨 HyperCat Functional DSL Demo")
    print("=" * 40)
    
    # Example 1: Clean functional category construction
    print("\n1. 🏗️  Functional Category Construction")
    
    # Old clunky way:
    # cat = Category("Test")
    # A = Object("A")
    # cat.add_object(A)
    # B = Object("B") 
    # cat.add_object(B)
    # f = Morphism("f", A, B)
    # cat.add_morphism(f)
    
    # New functional way:
    simple_cat = pipe(
        cat("SimpleCategory"),
        objects("A", "B", "C"),
        morphisms(
            ("f", "A", "B"),
            ("g", "B", "C"), 
            ("h", "A", "C")
        ),
        free_composition()
    ).build()
    
    print(f"Built category: {simple_cat.name}")
    print(f"Objects: {[obj.name for obj in simple_cat.objects]}")
    print(f"Morphisms: {len(simple_cat.morphisms)}")
    
    # Example 2: Finite sets with functions
    print("\n2. 📦 FinSet Construction")
    
    finset = pipe(
        cat("FinSet"),
        finite_sets(3),
        free_composition()
    ).build()
    
    print(f"FinSet objects: {[obj.name for obj in finset.objects]}")
    
    # Example 3: Poset category
    print("\n3. 📊 Poset Category")
    
    diamond = pipe(
        cat("Diamond"),
        poset(
            elements=["⊥", "a", "b", "⊤"],
            order=[("⊥", "a"), ("⊥", "b"), ("a", "⊤"), ("b", "⊤")]
        )
    ).build()
    
    print(f"Diamond poset: {diamond.name}")
    print(f"Elements: {[obj.name for obj in diamond.objects]}")
    
    # Example 4: Category operations
    print("\n4. 🔄 Category Operations")
    
    # Product category
    prod = product_category(simple_cat, diamond)
    print(f"Product category: {prod.name}")
    print(f"Product objects: {len(prod.objects)}")
    
    # Opposite category
    opposite = opposite_category(simple_cat)
    print(f"Opposite category: {opposite.name}")
    
    # Example 5: Functors
    print("\n5. ➡️  Functors")
    
    # Build target category
    target_cat = pipe(
        cat("Target"),
        objects("X", "Y"),
        morphisms(("φ", "X", "Y"))
    ).build()
    
    # Build functor
    F = pipe(
        functor("F", simple_cat, target_cat),
        lambda f: f.on_objects({"A": "X", "B": "Y", "C": "Y"}),
        lambda f: f.on_morphisms({"f": "φ", "g": "φ"})
    ).build()
    
    print(f"Functor {F.name}: {F.source.name} → {F.target.name}")
    
    print("\n✅ Functional DSL demonstration complete!")

# ============================================================================
# STANDARD CATEGORIES WITH DSL
# ============================================================================

class DSLStandardCategories:
    """Standard categories using functional DSL"""
    
    @staticmethod
    def finite_sets(max_size: int = 4) -> Cat:
        """FinSet using DSL"""
        return pipe(
            cat("FinSet"),
            finite_sets(max_size),
            free_composition()
        ).build()
    
    @staticmethod
    def chain_poset(length: int) -> Cat:
        """Chain poset using DSL"""
        elements = list(range(length))
        order = [(i, j) for i in range(length) for j in range(i, length)]
        
        return pipe(
            cat(f"Chain{length}"),
            poset(elements, order)
        ).build()
    
    @staticmethod
    def diamond_poset() -> Cat:
        """Diamond poset using DSL"""
        return pipe(
            cat("Diamond"),
            poset(
                elements=["⊥", "a", "b", "⊤"],
                order=[("⊥", "⊥"), ("a", "a"), ("b", "b"), ("⊤", "⊤"),
                       ("⊥", "a"), ("⊥", "b"), ("a", "⊤"), ("b", "⊤"), ("⊥", "⊤")]
            )
        ).build()
    
    @staticmethod
    def discrete_category(objects: List[str]) -> Cat:
        """Discrete category using DSL"""
        return pipe(
            cat("Discrete"),
            lambda builder: builder.with_objects(*objects)
        ).build()
    
    @staticmethod
    def terminal_category() -> Cat:
        """Terminal category using DSL"""
        return pipe(
            cat("Terminal"),
            objects("*")
        ).build()

# ============================================================================
# INTEGRATION WITH EXISTING HYPERCAT
# ============================================================================

def dsl_to_hypercat(dsl_cat: Cat) -> Category:
    """Convert DSL category to HyperCat Category"""
    return dsl_cat.to_hypercat()

def hypercat_to_dsl(hypercat: Category) -> Cat:
    """Convert HyperCat Category to DSL category"""
    # Convert mutable HyperCat to immutable DSL representation
    objects = frozenset(Obj(obj.name, obj.data) for obj in hypercat.objects)
    morphisms = frozenset(Mor(m.name, 
                             Obj(m.source.name, m.source.data),
                             Obj(m.target.name, m.target.data), 
                             m.data) 
                         for m in hypercat.morphisms)
    
    # Convert composition table
    composition = {}
    for (g, f), h in hypercat.composition.items():
        f_dsl = next(m for m in morphisms if m.name == f.name)
        g_dsl = next(m for m in morphisms if m.name == g.name)
        h_dsl = next(m for m in morphisms if m.name == h.name)
        composition[(f_dsl, g_dsl)] = h_dsl
    
    return Cat(
        name=hypercat.name,
        objects=objects,
        morphisms=morphisms,
        composition=frozendict(composition),
        identities=frozendict()  # Would need to extract identities
    )

if __name__ == "__main__":
    demonstrate_dsl()
